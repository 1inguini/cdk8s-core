# Kubernetes Cloud Development Kit

> Programmatically define Kubernetes applications using familiar programming
> languages.

The Kubernetes Cloud Development Kit (CDK) is a software development
framework for defining k8s applications using rich object-oriented APIs. It
allows developers to leverage the full power of software in order to define
abstract components called "constructs" which compose k8s resources or other
constructs into higher-level abstractions.

The Kubernetes CDK is based on the same design and technologies that are used to
for the [AWS Cloud Development Kit](https://aws.amazon.com/cdk), and k8s
constructs can interoperate with AWS CDK constructs to define cloud-native
applications that include both Kubernetes resources and AWS resources as first
class citizens.

## Approach

Kubernetes CDK apps are programs written in one of the supported programming
languages. They are structured as a tree of ["constructs"](https://docs.aws.amazon.com/cdk/latest/guide/constructs.html).

The root of the tree is an `App` construct. Within an app, users define any
number of stacks (classes that extend the `Stack` class) which are the CDK's
basic deployment unit.

Stack are, in turn, composed of any number of constructs, and eventually from
resources, which represent any Kubernetes resource, such as `Pod`, `Service`,
`Deployment`, `ReplicaSet`, etc.

CDK apps only _define_ Kubernetes applications, they don't actually apply them
to the cluster. When an app is executed, it *synthesizes* all the stacks defined
within the app into the `cdk.out` directory, and then those stacks can be
applied to any Kubernetes cluster using `kubectl apply -f cdk.out/stack`.

## Getting Started

Let's walk through a simple "Hello, World!" example. We will use the AWS CDK CLI
to initialize a new project and synthesize our Kubernetes CDK stacks, but we
will apply them using `kubectl` to our cluster.

Create a new CDK project (we'll use TypeScript):

```console
$ mkdir hello-k8scdk
$ cdk init -l typescript
```

Install the `k8scdk` module:

```console
$ npm i k8scdk
```

Delete the AWS CDK stack file that got generated by `cdk init` under `lib/` and
create a new file under `lib/hello-k8s.ts` for your first k8s stack:

```ts
import { Stack } from 'k8scdk';
import { Construct } from '@aws-cdk/core';

export class HelloKube extends Stack {
  constructor(scope: Construct, id: string) {
    super(scope, id);

  }
}
```

Now, inside your stack, define the service and deployment resources. This is
identical to defining the YAML described in https://github.com/paulbouwer/hello-kubernetes:

```ts
const label = { app: 'hello-k8s' };

new KubService(this, 'service', {
  type: 'LoadBalancer',
  ports: [ { port: 80, targetPort: 8080 } ],
  selector: label
});

new KubDeployment(this, 'deployment', {
  replicas: 2,
  selector: {
    matchLabels: label
  },
  template: {
    metadata: { labels: label },
    spec: {
      containers: [
        {
          name: 'hello-kubernetes',
          image: 'paulbouwer/hello-kubernetes:1.5',
          ports: [ { containerPort: 8080 } ]
        }
      ]
    }
  }
});
```

You'll see that the class names start with `Kub` (i.e. `KubDeployment`). This is
because these classes are automatically generated from the Kubernetes API spec
and represent 1:1 the spec. Similarly to the AWS CDK, these are called "Layer 1
Constructs" or, in short, L1s.

The idea behind the L1 layer is that it exposes the entire configuration surface
area through strongly-typed classes. In a sense, you can think of this layer as
a DOM (document object model).

Similarly to the AWS CDK, since this layer is limited in it's ability to offer a
rich object-oriented experience (since it is based purely on the backend API),
there is a good chance that we will be able to offer a richer API on top of
these that will offer a much better experience for developers.

OK, now that we have our stack defined, let's go back to our application's entry
point (under `bin/`) and replace the code with:

```ts
import { App, Stack } from '@aws-cdk/core';
import { HelloKube } from '../lib/hello-k8s';

const app = new App({ outdir: 'cdk.out' });

new HelloKube(app, 'hellowwwww');

app.synth();
```

Okay, we are ready to synthesize our first stack. Back to your terminal:

```console
$ node bin/hellowwwww-k8scdk.js
```

This should create a new directory `cdk.out` with a file `hello.k8s.yaml`
that contains the synthesized list of resources.

Now, all that remains is for you to apply this to your cluster:

```console
$ kubectl apply -f cdk.out/hellowwwww.k8s.yaml
service "hellowwwwwservice00939e38" created
deployment.apps "hellowwwwwdeploymentb485c4d9" created
```

You can find the service endpoint using:

```console
$ kubectl get service -o wide
NAME                        TYPE           CLUSTER-IP     EXTERNAL-IP                                                               PORT(S)        AGE       SELECTOR
hellowwwwwservice00939e38   LoadBalancer   172.20.23.55   a35b958eaaf1d11e9a26a0644f9d485a-1519168962.us-west-2.elb.amazonaws.com   80:30851/TCP   3m        app=hellowwwww
kubernetes                  ClusterIP      172.20.0.1     <none>                                                                    443/TCP        1h        <none>
```

And then, hit it with your browser!

You can find this example under [`examples/hello`](./examples/hello). Use the
`apply.sh` script to synthesize and apply to your cluster.

## License

Apache-2.0
